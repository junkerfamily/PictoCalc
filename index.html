<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pictogram Order Calculator</title>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" href="images/hamburger.png">
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    background: #fafafa;
    height: 100vh; /* fallback */
  }

  /* Use dynamic viewport height where supported to keep footer in view on mobile */
  @supports (height: 100dvh) {
    body { height: 100dvh; }
  }

  /* Grid layout - COMPACT for mobile */
  .grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(var(--cols, 3), 1fr);
    gap: var(--gap, 8px);  /* Smaller gap for tighter layout */
    padding: 8px;  /* Less padding for more content space */
    box-sizing: border-box;
    /* Ensure consistent cell sizing */
    grid-auto-rows: minmax(auto, max-content);  /* Prevent excessive row height */
    align-items: stretch;  /* Stretch items to fill available space */
    align-content: start;  /* Pack rows tightly at the top */
  }
  
  /* Apply scaling when needed to prevent footer overlap */
  .grid[style*="--tile-scale"] {
    transform-origin: top left;
  }
  
  .grid[style*="--tile-scale"] .item {
    transform: scale(var(--tile-scale, 1));
    transform-origin: center center;
  }

  /* Item card */
  .item {
    position: relative;
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 3px 8px rgba(0,0,0,0.12);
    transition: transform 0.15s ease;
    cursor: pointer;
    touch-action: manipulation;
    /* Ensure consistent cell dimensions */
    min-height: 0;
    display: flex;
    flex-direction: column;
  }
  .item:active {
    transform: scale(0.95);
  }

  /* Swipe layers */
  .item-content {
    position: relative;
    z-index: 1;
    transition: transform 0.15s ease;
    will-change: transform;
  }
  .swipe-bg {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 12px;
    opacity: 0;
    transition: opacity 0.15s ease;
    pointer-events: none;
    z-index: 0;
  }
  .swipe-bg .minus {
    background: #ff4444;
    color: #fff;
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: bold;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .item.dragging .swipe-bg {
    opacity: 1;
  }

  /* Fallback when image is missing: UNIFORM SQUARE SIZE */
  .no-image {
    width: 100%;
    aspect-ratio: 1 / 1;  /* Force square to match image items */
    /* Use flexbox for centering */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-weight: 900;
    color: #222;
    background: #fff;
    padding: 4px 4px 18px 4px;  /* Reduced bottom padding for more text space */
    box-sizing: border-box;
    /* Prefer wrapping at word boundaries; allow breaking if needed */
    white-space: normal;
    word-break: break-word;
    overflow-wrap: anywhere;
    hyphens: auto;
    line-height: 0.9;  /* Tighter line spacing for better space usage */
    /* Ensure consistent cell dimensions */
    overflow: hidden;
    position: relative;
  }
  
  /* Special handling for multi-line text containers - UNIFORM SIZE */
  .no-image.multi-line {
    aspect-ratio: 1 / 1 !important;  /* Force square like image items */
    min-height: unset !important;   /* Let aspect-ratio control height */
    max-height: none !important;    /* Remove any height constraints */
    height: auto !important;
    padding: 4px 4px 12px 4px !important;  /* Reduce bottom padding to avoid clipping last line */
    justify-content: center !important;     /* Center text like image items */
    overflow: hidden !important;    /* Prevent overflow for uniform appearance */
  }
  
  /* Production: Clean containers without debug borders */
  .no-image {
    /* RESET: Remove any transforms that might be applied to containers */
    transform: none !important;
    scale: none !important;
    zoom: 1 !important;
  }
  
  /* Production: Clean text spans without debug borders */
  .no-image-text {
    /* RESET: Remove any transforms that might be applied */
    transform: none !important;
    scale: none !important;
    zoom: 1 !important;
  }
  
  /* Font-size scaling for different scale levels - LARGER for better space usage */
  .no-image[data-scale-level="1"] .no-image-text { font-size: 5.5rem; }
  .no-image[data-scale-level="2"] .no-image-text { font-size: 5.0rem; }
  .no-image[data-scale-level="3"] .no-image-text { font-size: 4.5rem; }
  .no-image[data-scale-level="4"] .no-image-text { font-size: 4.0rem; }
  .no-image[data-scale-level="5"] .no-image-text { font-size: 3.5rem; }
  .no-image[data-scale-level="6"] .no-image-text { font-size: 3.0rem; }
  .no-image[data-scale-level="7"] .no-image-text { font-size: 2.5rem; }
  .no-image[data-scale-level="8"] .no-image-text { font-size: 2.0rem; }
  .no-image[data-scale-level="9"] .no-image-text { font-size: 1.5rem; }
  .no-image[data-scale-level="10"] .no-image-text { font-size: 1.0rem; }
  
  /* Color options for text */
  .no-image[data-color="red"] .no-image-text { color: #dc2626; }
  .no-image[data-color="blue"] .no-image-text { color: #2563eb; }
  .no-image[data-color="green"] .no-image-text { color: #16a34a; }
  .no-image[data-color="black"] .no-image-text { color: #000000; }
  .no-image[data-color="orange"] .no-image-text { color: #ea580c; }
  .no-image[data-color="pink"] .no-image-text { color: #db2777; }
  .no-image[data-color="purple"] .no-image-text { color: #9333ea; }
  .no-image[data-color="gold"] .no-image-text { color: #ca8a04; }
  
  /* Debug: show scale factor visually - comment out for production */
  /*
  .no-image[data-scale-adjust]::before {
    content: "scale " attr(data-scale-adjust);
    position: absolute;
    top: 2px;
    left: 2px;
    background: rgba(255, 0, 0, 0.8);
    color: white;
    font-size: 10px;
    padding: 2px 4px;
    border-radius: 3px;
    font-weight: bold;
  }
  */
  .no-image-text {
    display: block;
    width: 100%;
    will-change: transform;
    transform-origin: center center;
    /* Ensure text doesn't affect cell dimensions when scaled */
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }
  
  /* Special handling for text with explicit newlines */
  .no-image-text[style*="white-space: pre-line"] {
    word-break: normal !important;
    white-space: pre-line !important;
    overflow-wrap: normal !important;
    hyphens: none !important;
    line-height: 0.8 !important;
    transform-origin: center center !important;
  }
  
  /* Force proper line breaks for items with newlines */
  .no-image-text {
    word-break: normal !important;
    overflow-wrap: normal !important;
  }
  .no-image-mode .label { display: none; }
  
  /* Padding for text-only items - UNIFORM with image items */
  .no-image-mode .no-image {
    aspect-ratio: 1 / 1 !important;  /* Force square to match image items */
    padding: 4px 4px 30px 4px !important;  /* Minimal padding for more text space */
    min-height: unset !important;  /* Let aspect-ratio control height */
  }

  /* Item image */
  .item img {
    width: 100%;
    display: block;
    aspect-ratio: 1 / 1;
    object-fit: cover;  /* Cover the entire container, no white space */
    background: transparent;  /* No background needed for JPGs */
  }

  /* Name label */
  .label {
    text-align: center;
    padding: 6px;
    font-size: var(--label-font, 14px);
    font-weight: 500;
    color: #333;
  }

  /* Count badge */
  .count {
    position: absolute;
    top: 6px;
    right: 6px;
    background: #ff4444;
    color: white;
    padding: 4px 8px;
    border-radius: 20px;
    font-size: 13px;
    min-width: 20px;
    text-align: center;
    font-weight: bold;
  }
  
  /* Count badge for text-only items - use bottom space to prevent overlap */
  .no-image-mode .count {
    top: auto;
    bottom: 0;  /* Sit flush to the bottom edge for maximum text room */
    right: 8px;
    background: #ff4444;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    border: 2px solid white;  /* White border for better visibility */
    font-size: 14px;  /* Slightly larger for better visibility in bottom position */
    padding: 5px 9px;  /* More padding for better appearance */
  }

  /* Swipe hint (only visible while swiping) */
  .item.swiping::after {
    content: "Swipe left to remove";
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #888;
    background: rgba(255,255,255,0.85);
    padding: 4px 6px;
    border-radius: 6px;
    pointer-events: none;
  }

  /* Footer total bar */
  .footer {
    background: white;
    border-top: 1px solid #ddd;
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: bold;
    box-shadow: 0 -2px 6px rgba(0,0,0,0.06);
    position: sticky;
    bottom: 0;
  }

  /* Reset button */
  button {
    background: #ff4444;
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  button:hover {
    background: #dd2222;
  }
  /* Make only the Reset button ~10% longer without affecting menu tabs */
  #resetBtn {
    padding: 8px 16px; /* was 8px 14px */
  }

  /* Error banner */
  .error {
    background: #fff3cd;
    color: #664d03;
    border-bottom: 1px solid #ffe69c;
    padding: 8px 12px;
    font-size: 14px;
    display: none;
  }

  /* Menu tabs in footer */
  .menu-tabs {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
    align-items: center;
  }
  .menu-tabs .tab {
    background: #f3f4f6;
    color: #111827;
    border: 1px solid #e5e7eb;
    padding: 6px 10px;
    border-radius: 999px;
    font-size: 13px;
    cursor: pointer;
  }
  .menu-tabs .tab.active {
    background: #111827;
    color: #ffffff;
    border-color: #111827;
  }
</style>
</head>
<body>

<div id="error" class="error"></div>

<!-- Menu Grid -->
<div class="grid" id="menuGrid"></div>

<!-- Total Footer -->
<div class="footer">
  <div class="menu-tabs" id="menuTabs"></div>
  <div>
    <button id="resetBtn">Reset</button>
    <span style="margin-left:12px">Total: $<span id="total">0.00</span></span>
  </div>
  
</div>

<script>
  let configData = null;
  let currentMenu = "";
  let items = [];
  let counts = {};

  async function init() {
    try {
      const url = `config.json?ts=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const json = await res.json();
      // Support both legacy array format and new multi-menu format
      if (Array.isArray(json)) {
        configData = { defaultMenu: "Menu A", menus: { "Menu A": json } };
      } else {
        configData = json;
      }
      hideError();
    } catch (err) {
      console.error("Failed to load config.json", err);
      showError("Failed to load config.json. If running locally, start a server: python3 -m http.server");
      configData = { defaultMenu: "Menu A", menus: { "Menu A": [] } };
    }
    const menuNames = Object.keys(configData.menus || {});
    currentMenu = (configData.defaultMenu && menuNames.includes(configData.defaultMenu)) ? configData.defaultMenu : (menuNames[0] || "Menu A");
    setMenu(currentMenu);
    renderMenuTabs();
  }

  function setMenu(menuName) {
    currentMenu = menuName;
    items = (configData && configData.menus && configData.menus[menuName]) || [];
    counts = Object.fromEntries(items.map(i => [i.name, 0]));
    updateTotal();
    renderMenu();
    highlightActiveTab();
  }

  function renderMenuTabs() {
    const container = document.getElementById("menuTabs");
    if (!container || !configData) return;
    container.innerHTML = "";
    const menus = Object.keys(configData.menus || {});
    menus.forEach(name => {
      const btn = document.createElement("button");
      btn.className = "tab";
      btn.textContent = name;
      btn.onclick = () => {
        // Reset totals and switch menu
        setMenu(name);
      };
      container.appendChild(btn);
    });
    highlightActiveTab();
  }

  function highlightActiveTab() {
    const container = document.getElementById("menuTabs");
    if (!container) return;
    for (const el of container.querySelectorAll('.tab')) {
      el.classList.toggle('active', el.textContent === currentMenu);
    }
  }

  function showError(message) {
    const el = document.getElementById("error");
    if (!el) return;
    el.textContent = message;
    el.style.display = "block";
  }

  function hideError() {
    const el = document.getElementById("error");
    if (!el) return;
    el.style.display = "none";
  }

  function renderMenu() {
    const grid = document.getElementById("menuGrid");
    grid.innerHTML = "";
    items.forEach(item => {
      const div = document.createElement("div");
      div.className = "item";
      const hasImage = !!(item.image && String(item.image).trim().length > 0);
      const textScaleParam = Number.isFinite(Number(item.scale)) ? Number(item.scale) : 1;
      const textScaleFactor = Math.max(0.1, 1 - 0.1 * (textScaleParam - 1));
      console.log(`Item: ${item.name}, HasImage: ${hasImage}, Scale: ${textScaleParam}, Factor: ${textScaleFactor}`);
      div.innerHTML = `
        <div class="swipe-bg"><span class="minus">-1</span></div>
        <div class="item-content">
          ${hasImage ? `<img src="${item.image}" alt="${item.name}">` : `<div class=\"no-image\" data-scale-adjust=\"${textScaleFactor}\" data-scale-level=\"${textScaleParam}\" data-color=\"${item.color || 'black'}\"><span class=\"no-image-text\">${item.name}</span></div>`}
          ${counts[item.name] > 0 ? `<div class=\"count\">${counts[item.name]}</div>` : ""}
          <div class="label">${item.name}</div>
        </div>
      `;
      if (!hasImage) {
        div.classList.add('no-image-mode');
        // support manual line breaks ("\n") in names when no image
        const span = div.querySelector('.no-image-text');
        if (span) {
          console.log(`Raw item name: "${item.name}"`);
          console.log(`Raw item name length: ${item.name.length}`);
          console.log(`Raw item name char codes: ${Array.from(item.name).map(c => c.charCodeAt(0))}`);
          
          // Handle newlines more directly
          let processedText = item.name || "";
          if (processedText.includes('\\n')) {
            // Replace literal \n with actual newlines, then with <br> tags
            processedText = processedText.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
            console.log(`Found \\n, processed to: "${processedText}"`);
          }
          
          const safe = processedText
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          
          console.log(`Final HTML: "${safe}"`);
          span.innerHTML = safe;
          
          // Force proper line breaks for items with explicit newlines
          if (item.name && item.name.includes('\\n')) {
            console.log(`Found \\n in name, applying special styling to: "${item.name}"`);
            span.style.whiteSpace = 'pre-line';
            span.style.wordBreak = 'normal';
            span.style.overflowWrap = 'normal';
            span.style.hyphens = 'none';
            span.style.lineHeight = '0.8';  // Very tight line spacing for multi-line text
            
            // Add multi-line class to the container
            const noImageDiv = div.querySelector('.no-image');
            if (noImageDiv) {
              noImageDiv.classList.add('multi-line');
              console.log(`Added multi-line class to container for: "${item.name}"`);
            } else {
              console.log(`ERROR: Could not find .no-image div for: "${item.name}"`);
            }
          } else {
            console.log(`No \\n found in name: "${item.name}"`);
            // Check for actual newlines (not just literal \n)
            if (item.name && item.name.includes('\n')) {
              console.log('FOUND ACTUAL NEWLINES! Applying multi-line styling');
              span.style.whiteSpace = 'pre-line';
              span.style.wordBreak = 'normal';
              span.style.overflowWrap = 'normal';
              span.style.hyphens = 'none';
              span.style.lineHeight = '0.8';
              
              // Add multi-line class to the container
              const noImageDiv = div.querySelector('.no-image');
              if (noImageDiv) {
                noImageDiv.classList.add('multi-line');
                console.log(`Added multi-line class for ACTUAL newlines: "${item.name}"`);
              }
            }
          }
        }
      }
      let suppressClick = false;
      const content = div.querySelector('.item-content');
      // Image fallback: replace with large text if image fails to load
      const imgEl = div.querySelector('img');
      if (imgEl) {
        imgEl.addEventListener('error', () => {
          const text = document.createElement('div');
          text.className = 'no-image';
          text.setAttribute('data-scale-adjust', String(textScaleFactor));
          text.setAttribute('data-color', item.color || 'black');
          const span = document.createElement('span');
          span.className = 'no-image-text';
          // Handle newlines more directly
          let processedText = item.name || "";
          if (processedText.includes('\\n')) {
            // Replace literal \n with actual newlines, then with <br> tags
            processedText = processedText.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
          }
          
          const safe = processedText
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          
          span.innerHTML = safe;
          
          // Force proper line breaks for items with explicit newlines
          if (item.name && item.name.includes('\\n')) {
            span.style.whiteSpace = 'pre-line';
            span.style.wordBreak = 'normal';
            span.style.overflowWrap = 'normal';
            span.style.hyphens = 'none';
            span.style.lineHeight = '0.8';  // Very tight line spacing for multi-line text
            
            // Add multi-line class to the container
            text.classList.add('multi-line');
          }
          text.appendChild(span);
          imgEl.replaceWith(text);
          div.classList.add('no-image-mode');
          // CONTROLLED SCALING: Re-enable scaling but only for multi-line text
          if (text.classList.contains('multi-line')) {
            console.log('Applying controlled scaling to multi-line fallback text');
            requestAnimationFrame(() => fitTextToBoxControlled(text));
          }
        });
      } else {
        // If we rendered text directly, ensure it fits
        const text = div.querySelector('.no-image');
        // CONTROLLED SCALING: Re-enable scaling but only for multi-line text
        if (text && text.classList.contains('multi-line')) {
          console.log('FOUND MULTI-LINE TEXT - classes:', text.classList.toString());
          console.log('Container element:', text);
          requestAnimationFrame(() => fitTextToBoxControlled(text));
        } else if (text) {
          console.log('NOT MULTI-LINE - classes:', text.classList.toString());
        }
        
        // DEBUG: Log what's happening with this container
        if (text) {
          console.log('Text container found:', text);
          console.log('Container classes:', text.className);
          console.log('Container computed style:', window.getComputedStyle(text));
          const span = text.querySelector('.no-image-text');
          if (span) {
            console.log('Text span style:', window.getComputedStyle(span));
            console.log('Text span transform:', span.style.transform);
          }
        }
      }
      div.addEventListener("click", (event) => {
        if (suppressClick) { suppressClick = false; return; }
        counts[item.name]++;
        updateTotal();
        updateItemCount(item.name);  // Efficient update instead of full re-render
      });

      // Swipe-to-decrement (left or down swipe)
      let startX = null, startY = null, dragging = false, currentDX = 0, currentDY = 0, dragAxis = null;
      div.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        startX = t.clientX; startY = t.clientY;
        dragging = false; currentDX = 0; currentDY = 0; dragAxis = null;
        if (content) content.style.transition = "none";
      }, { passive: true });
      div.addEventListener("touchmove", (e) => {
        if (startX === null) return;
        const t = e.touches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        if (!dragging) {
          if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
            dragging = true; dragAxis = 'x';
          } else if (Math.abs(dy) > 10 && Math.abs(dy) > Math.abs(dx)) {
            dragging = true; dragAxis = 'y';
          }
        }
        if (dragging && dragAxis) {
          e.preventDefault();
          currentDX = dx;
          currentDY = dy;
          if (dragAxis === 'x') {
            const translateX = Math.min(0, dx); // only left
            if (content) content.style.transform = `translateX(${translateX}px)`;
            div.classList.toggle('dragging', translateX < 0);
          } else if (dragAxis === 'y') {
            const translateY = Math.max(0, dy); // only down
            if (content) content.style.transform = `translateY(${translateY}px)`;
            div.classList.toggle('dragging', translateY > 0);
          }
        }
      }, { passive: false });
      const endSwipe = () => {
        if (dragging) {
          const leftSwipe = currentDX <= -50;
          const downSwipe = currentDY >= 50;
          if ((leftSwipe || downSwipe) && counts[item.name] > 0) {
            counts[item.name]--;
            updateTotal();
            suppressClick = true;
            updateItemCount(item.name);  // Efficient update instead of full re-render
          }
          if (content) {
            content.style.transition = "transform 0.15s ease";
            content.style.transform = "translate(0, 0)";
          }
          div.classList.remove('dragging');
        }
        startX = startY = null; dragging = false; currentDX = 0; currentDY = 0; dragAxis = null;
      };
      div.addEventListener("touchend", endSwipe);
      div.addEventListener("touchcancel", endSwipe);
      grid.appendChild(div);
    });
    layoutGrid();
  }

  // Controlled scaling specifically for multi-line text
  function fitTextToBoxControlled(el) {
    if (!el) {
      console.log('fitTextToBoxControlled: No element provided');
      return;
    }
    const span = el.querySelector('.no-image-text');
    if (!span) {
      console.log('fitTextToBoxControlled: No text span found');
      return;
    }
    
    console.log('fitTextToBoxControlled: Starting controlled scaling');
    console.log('Element:', el);
    console.log('Span:', span);
    console.log('Span innerHTML:', span.innerHTML);
    
    // Force a smaller font size for multi-line text
    console.log('FORCING smaller font size for multi-line text');
    span.style.fontSize = '0.7rem';
    span.style.lineHeight = '0.9';
    
    // Also try to measure and log dimensions
    setTimeout(() => {
      const containerHeight = el.clientHeight;
      const textHeight = span.scrollHeight;
      console.log(`After font change - Container height: ${containerHeight}px, Text height: ${textHeight}px`);
    }, 100);
  }

  // Fit big bold text into a square box using transform scale only
  function fitTextToBox(el) {
    if (!el) return;
    const span = el.querySelector('.no-image-text');
    if (!span) return;
    // Reset baseline so measurement is consistent
    span.style.transform = 'scale(1)';
    span.style.fontSize = '100px';
    span.style.width = '100%';
    // Base margin (35%) and per-item scale factor (1..10 => 100%..10%)
    const userFactorRaw = parseFloat(el.getAttribute('data-scale-adjust') || '1');
    const userFactor = Number.isFinite(userFactorRaw) ? userFactorRaw : 1;
    
    // Check if this is multi-line text (has newlines)
    const isMultiLine = span.innerHTML.includes('<br>') || span.innerHTML.includes('\n');
    
    // Use different scaling approach for multi-line text
    let factor;
    if (isMultiLine) {
      // For multi-line text, use much more conservative scaling to ensure all lines fit
      factor = 0.25 * userFactor;  // Much less aggressive scaling
      console.log(`fitTextToBox: MULTI-LINE text, userFactor=${userFactor}, factor=${factor}`);
    } else {
      factor = 0.65 * userFactor;
      console.log(`fitTextToBox: single-line text, userFactor=${userFactor}, factor=${factor}`);
    }
    
    // Measure available vs content size
    const cw = el.clientWidth || 1;
    const ch = el.clientHeight || 1;
    const rect = span.getBoundingClientRect();
    const sw = rect.width || 1;
    const sh = rect.height || 1;
    
    // For multi-line text, be more conservative with height scaling
    let scale;
    if (isMultiLine) {
      // Prioritize fitting the height over width for multi-line text
      const widthScale = cw / sw;
      const heightScale = ch / sh;
      scale = Math.max(0.1, Math.min(1, factor * Math.min(widthScale, heightScale * 1.2))); // Give 20% more height allowance
    } else {
      scale = Math.max(0.1, Math.min(1, factor * Math.min(cw / sw, ch / sh)));
    }
    
    console.log(`fitTextToBox: final scale=${scale}, isMultiLine=${isMultiLine}`);
    console.log(`Container dimensions: ${cw}x${ch}, Content dimensions: ${sw}x${sh}`);
    console.log(`Text content: "${span.innerHTML}"`);
    
    // Apply scale without affecting layout by using transform-origin and ensuring no overflow
    span.style.transform = `scale(${scale})`;
    span.style.transformOrigin = 'center center';
    
    // Ensure the scaled text doesn't affect cell dimensions but allow text to be visible
    el.style.overflow = 'visible';
    
    // Log the final result for debugging
    console.log(`Text scaling complete: scale=${scale}, container overflow=${el.style.overflow}`);
  }

  function layoutGrid() {
    const grid = document.getElementById("menuGrid");
    if (!grid) return;
    const n = items.length || 0;
    const styles = getComputedStyle(grid);
    const gap = parseFloat(styles.gap) || 12;
    const paddingLeft = parseFloat(styles.paddingLeft) || 12;
    const paddingRight = parseFloat(styles.paddingRight) || 12;
    const paddingTop = parseFloat(styles.paddingTop) || 12;
    const paddingBottom = parseFloat(styles.paddingBottom) || 12;
    const footer = document.querySelector(".footer");
    const footerHeight = footer ? footer.getBoundingClientRect().height : 0;
    const availableWidth = window.innerWidth - paddingLeft - paddingRight;
    const availableHeight = window.innerHeight - footerHeight - paddingTop - paddingBottom;

    let bestCols = Math.min(3, n || 3);
    let bestTileWidth = 0;
    let bestLabelFont = 14;
    const maxCols = Math.min(Math.max(1, n), 8);
    for (let cols = 1; cols <= maxCols; cols++) {
      const rows = Math.max(1, Math.ceil(n / cols));
      const tileWidth = (availableWidth - gap * (cols - 1)) / cols;
      const labelFont = Math.max(11, Math.min(16, Math.round(tileWidth * 0.15)));
      
      // Calculate actual label height accounting for text wrapping - more conservative estimate
      const maxLabelHeight = Math.max(...items.map(item => {
        const charsPerLine = Math.floor(tileWidth / (labelFont * 0.5)); // More generous chars per line
        const lines = Math.ceil(item.name.length / charsPerLine);
        return Math.max(20, lines * (labelFont + 2) + 8); // Minimum 20px, tighter line spacing
      }));
      
      const tileHeight = tileWidth + maxLabelHeight; // Image + actual label height
      const totalHeight = rows * tileHeight + gap * (rows - 1);
      if (tileWidth > bestTileWidth && totalHeight <= availableHeight) {
        bestTileWidth = tileWidth;
        bestCols = cols;
        bestLabelFont = labelFont;
      }
    }
    // If nothing fit, pick the configuration that yields the largest tiles and then clamp height
    if (bestTileWidth === 0) {
      let bestScore = -Infinity;
      for (let cols = 1; cols <= maxCols; cols++) {
        const rows = Math.max(1, Math.ceil(n / cols));
        const tileWidth = (availableWidth - gap * (cols - 1)) / cols;
        const labelFont = Math.max(11, Math.min(16, Math.round(tileWidth * 0.15)));
        
        // Calculate actual label height accounting for text wrapping - more conservative estimate
        const maxLabelHeight = Math.max(...items.map(item => {
          const charsPerLine = Math.floor(tileWidth / (labelFont * 0.5)); // More generous chars per line
          const lines = Math.ceil(item.name.length / charsPerLine);
          return Math.max(20, lines * (labelFont + 2) + 8); // Minimum 20px, tighter line spacing
        }));
        
        const tileHeight = tileWidth + maxLabelHeight; // Image + actual label height
        const totalHeight = rows * tileHeight + gap * (rows - 1);
        const score = tileWidth - Math.max(0, totalHeight - availableHeight); // prefer large tiles with less overflow
        if (score > bestScore) {
          bestScore = score;
          bestCols = cols;
          bestTileWidth = tileWidth;
          bestLabelFont = labelFont;
        }
      }
    }
    
    // Calculate final dimensions and check for overlap
    const rows = Math.max(1, Math.ceil(n / bestCols));
    
    // Calculate actual label height for final calculation - more conservative estimate
    const maxLabelHeight = Math.max(...items.map(item => {
      const charsPerLine = Math.floor(bestTileWidth / (bestLabelFont * 0.5)); // More generous chars per line
      const lines = Math.ceil(item.name.length / charsPerLine);
      return Math.max(20, lines * (bestLabelFont + 2) + 8); // Minimum 20px, tighter line spacing
    }));
    
    const tileHeight = bestTileWidth + maxLabelHeight; // Image + actual label height
    const totalHeight = rows * tileHeight + gap * (rows - 1);
    
    // If content would overlap the footer, scale down all rows proportionally
    let scaleFactor = 1;
    if (totalHeight > availableHeight) {
      scaleFactor = Math.max(0.7, availableHeight / totalHeight); // Minimum 70% of original size (less conservative)
      console.log(`Scaling down grid by factor ${scaleFactor.toFixed(2)} to prevent footer overlap`);
    } else if (totalHeight < availableHeight * 0.8) {
      // If we're using less than 80% of available space, try to scale up slightly
      scaleFactor = Math.min(1.1, availableHeight / totalHeight);
      console.log(`Scaling up grid by factor ${scaleFactor.toFixed(2)} to use more space`);
    }
    
    // Apply scaling to tile dimensions
    const scaledTileWidth = bestTileWidth * scaleFactor;
    const scaledLabelFont = Math.max(10, bestLabelFont * scaleFactor); // Minimum 10px font
    
    grid.style.setProperty("--cols", String(bestCols));
    document.documentElement.style.setProperty("--label-font", `${scaledLabelFont}px`);
    grid.style.setProperty("--dec-top", `${Math.max(20, Math.floor(scaledTileWidth * 0.35))}px`);
    
    // Apply scaling to the grid items themselves
    if (scaleFactor < 1) {
      grid.style.setProperty("--tile-scale", String(scaleFactor));
      grid.style.setProperty("--tile-width", `${scaledTileWidth}px`);
    } else {
      grid.style.removeProperty("--tile-scale");
      grid.style.removeProperty("--tile-width");
    }
    
    // Refit any fallback text boxes after layout changes - DISABLED to prevent interference
    // grid.querySelectorAll('.no-image').forEach((el) => fitTextToBox(el));
  }

  window.addEventListener("resize", layoutGrid);

  function updateTotal() {
    const total = items.reduce((sum, item) => sum + counts[item.name] * item.price, 0);
    document.getElementById("total").textContent = total.toFixed(2);
  }

  // Efficient function to update just the count badge for a specific item
  function updateItemCount(itemName) {
    const grid = document.getElementById("menuGrid");
    const itemDivs = grid.querySelectorAll('.item');
    
    // Find the div for this specific item
    for (let itemDiv of itemDivs) {
      const label = itemDiv.querySelector('.label');
      if (label && label.textContent === itemName) {
        const existingCount = itemDiv.querySelector('.count');
        const currentCount = counts[itemName];
        
        if (currentCount > 0) {
          if (existingCount) {
            // Update existing count badge
            existingCount.textContent = currentCount;
          } else {
            // Create new count badge
            const countBadge = document.createElement('div');
            countBadge.className = 'count';
            countBadge.textContent = currentCount;
            itemDiv.querySelector('.item-content').appendChild(countBadge);
          }
        } else if (existingCount) {
          // Remove count badge if count is 0
          existingCount.remove();
        }
        break;
      }
    }
  }

  document.getElementById("resetBtn").onclick = () => {
    for (let key in counts) counts[key] = 0;
    updateTotal();
    renderMenu();
  };

  init();
</script>
</body>
</html>
