<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pictogram Order Calculator</title>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" href="images/hamburger.png">
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    background: #fafafa;
    height: 100vh; /* fallback */
  }

  /* Use dynamic viewport height where supported to keep footer in view on mobile */
  @supports (height: 100dvh) {
    body { height: 100dvh; }
  }

  /* Grid layout */
  .grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(var(--cols, 3), 1fr);
    gap: var(--gap, 12px);
    padding: 12px;
    box-sizing: border-box;
    /* Ensure consistent cell sizing */
    grid-auto-rows: 1fr;
    align-items: start;
  }

  /* Item card */
  .item {
    position: relative;
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 3px 8px rgba(0,0,0,0.12);
    transition: transform 0.15s ease;
    cursor: pointer;
    touch-action: manipulation;
    /* Ensure consistent cell dimensions */
    min-height: 0;
    display: flex;
    flex-direction: column;
  }
  .item:active {
    transform: scale(0.95);
  }

  /* Swipe layers */
  .item-content {
    position: relative;
    z-index: 1;
    transition: transform 0.15s ease;
    will-change: transform;
  }
  .swipe-bg {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 12px;
    opacity: 0;
    transition: opacity 0.15s ease;
    pointer-events: none;
    z-index: 0;
  }
  .swipe-bg .minus {
    background: #ff4444;
    color: #fff;
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: bold;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .item.dragging .swipe-bg {
    opacity: 1;
  }

  /* Fallback when image is missing: big bold text fits square */
  .no-image {
    width: 100%;
    min-height: 150px;  /* Ensure adequate height for text */
    /* EXPERIMENTAL: Use flexbox instead of grid for better control */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    font-weight: 900;
    color: #222;
    background: #fff;
    padding: 15px;
    box-sizing: border-box;
    /* Prefer wrapping at word boundaries; allow breaking if needed */
    white-space: normal;
    word-break: break-word;
    overflow-wrap: anywhere;
    hyphens: auto;
    line-height: 1.0;
    /* Ensure consistent cell dimensions regardless of text scaling */
    overflow: visible;
    position: relative;
  }
  
  /* Special handling for multi-line text containers */
  .no-image.multi-line {
    aspect-ratio: unset !important;
    min-height: 280px !important;  /* Much more height for multi-line text */
    max-height: none !important;   /* Remove any height constraints */
    height: auto !important;
    padding: 30px 12px 50px 12px !important;  /* Extra bottom padding for count badge */
    justify-content: flex-start !important;  /* Align to top instead of center */
    overflow: visible !important;  /* Make sure nothing gets clipped */
  }
  
  /* Production: Clean containers without debug borders */
  .no-image {
    /* RESET: Remove any transforms that might be applied to containers */
    transform: none !important;
    scale: none !important;
    zoom: 1 !important;
  }
  
  /* Production: Clean text spans without debug borders */
  .no-image-text {
    /* RESET: Remove any transforms that might be applied */
    transform: none !important;
    scale: none !important;
    zoom: 1 !important;
  }
  
  /* Font-size scaling for different scale levels */
  .no-image[data-scale-level="1"] .no-image-text { font-size: 4rem; }
  .no-image[data-scale-level="2"] .no-image-text { font-size: 3.6rem; }
  .no-image[data-scale-level="3"] .no-image-text { font-size: 3.2rem; }
  .no-image[data-scale-level="4"] .no-image-text { font-size: 2.8rem; }
  .no-image[data-scale-level="5"] .no-image-text { font-size: 2.4rem; }
  .no-image[data-scale-level="6"] .no-image-text { font-size: 2.0rem; }
  .no-image[data-scale-level="7"] .no-image-text { font-size: 1.6rem; }
  .no-image[data-scale-level="8"] .no-image-text { font-size: 1.2rem; }
  .no-image[data-scale-level="9"] .no-image-text { font-size: 0.8rem; }
  .no-image[data-scale-level="10"] .no-image-text { font-size: 0.4rem; }
  
  /* Color options for text */
  .no-image[data-color="red"] .no-image-text { color: #dc2626; }
  .no-image[data-color="blue"] .no-image-text { color: #2563eb; }
  .no-image[data-color="green"] .no-image-text { color: #16a34a; }
  .no-image[data-color="black"] .no-image-text { color: #000000; }
  .no-image[data-color="orange"] .no-image-text { color: #ea580c; }
  .no-image[data-color="pink"] .no-image-text { color: #db2777; }
  .no-image[data-color="purple"] .no-image-text { color: #9333ea; }
  .no-image[data-color="gold"] .no-image-text { color: #ca8a04; }
  
  /* Debug: show scale factor visually - comment out for production */
  /*
  .no-image[data-scale-adjust]::before {
    content: "scale " attr(data-scale-adjust);
    position: absolute;
    top: 2px;
    left: 2px;
    background: rgba(255, 0, 0, 0.8);
    color: white;
    font-size: 10px;
    padding: 2px 4px;
    border-radius: 3px;
    font-weight: bold;
  }
  */
  .no-image-text {
    display: block;
    width: 100%;
    will-change: transform;
    transform-origin: center center;
    /* Ensure text doesn't affect cell dimensions when scaled */
    max-width: 100%;
    max-height: 100%;
    overflow: hidden;
  }
  
  /* Special handling for text with explicit newlines */
  .no-image-text[style*="white-space: pre-line"] {
    word-break: normal !important;
    white-space: pre-line !important;
    overflow-wrap: normal !important;
    hyphens: none !important;
    line-height: 0.8 !important;
    transform-origin: center center !important;
  }
  
  /* Force proper line breaks for items with newlines */
  .no-image-text {
    word-break: normal !important;
    overflow-wrap: normal !important;
  }
  .no-image-mode .label { display: none; }
  
  /* Padding for text-only items - reserve bottom space for count badge */
  .no-image-mode .no-image {
    padding: 15px 12px 45px 12px !important;  /* Extra bottom padding for count badge */
    min-height: 120px !important;  /* Ensure minimum height for single-line text */
  }

  /* Item image */
  .item img {
    width: 100%;
    display: block;
    aspect-ratio: 1 / 1;
    object-fit: contain;
    background: #fff;
  }

  /* Name label */
  .label {
    text-align: center;
    padding: 6px;
    font-size: var(--label-font, 14px);
    font-weight: 500;
    color: #333;
  }

  /* Count badge */
  .count {
    position: absolute;
    top: 6px;
    right: 6px;
    background: #ff4444;
    color: white;
    padding: 4px 8px;
    border-radius: 20px;
    font-size: 13px;
    min-width: 20px;
    text-align: center;
    font-weight: bold;
  }
  
  /* Count badge for text-only items - use bottom space to prevent overlap */
  .no-image-mode .count {
    top: auto;
    bottom: 8px;
    right: 8px;
    background: #ff4444;
    box-shadow: 0 3px 6px rgba(0,0,0,0.3);
    border: 2px solid white;  /* White border for better visibility */
    font-size: 14px;  /* Slightly larger for better visibility in bottom position */
    padding: 5px 9px;  /* More padding for better appearance */
  }

  /* Swipe hint (only visible while swiping) */
  .item.swiping::after {
    content: "Swipe left to remove";
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #888;
    background: rgba(255,255,255,0.85);
    padding: 4px 6px;
    border-radius: 6px;
    pointer-events: none;
  }

  /* Footer total bar */
  .footer {
    background: white;
    border-top: 1px solid #ddd;
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: bold;
    box-shadow: 0 -2px 6px rgba(0,0,0,0.06);
    position: sticky;
    bottom: 0;
  }

  /* Reset button */
  button {
    background: #ff4444;
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  button:hover {
    background: #dd2222;
  }

  /* Error banner */
  .error {
    background: #fff3cd;
    color: #664d03;
    border-bottom: 1px solid #ffe69c;
    padding: 8px 12px;
    font-size: 14px;
    display: none;
  }
</style>
</head>
<body>

<div id="error" class="error"></div>

<!-- Menu Grid -->
<div class="grid" id="menuGrid"></div>

<!-- Total Footer -->
<div class="footer">
  <button id="resetBtn">Reset</button>
  <div>Total: $<span id="total">0.00</span></div>
</div>

<script>
  let items = [];
  let counts = {};

  async function init() {
    try {
      const url = `config.json?ts=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      items = await res.json();
      hideError();
    } catch (err) {
      console.error("Failed to load config.json", err);
      showError("Failed to load config.json. If running locally, start a server: python3 -m http.server");
      items = [];
    }
    counts = Object.fromEntries(items.map(i => [i.name, 0]));
    renderMenu();
  }

  function showError(message) {
    const el = document.getElementById("error");
    if (!el) return;
    el.textContent = message;
    el.style.display = "block";
  }

  function hideError() {
    const el = document.getElementById("error");
    if (!el) return;
    el.style.display = "none";
  }

  function renderMenu() {
    const grid = document.getElementById("menuGrid");
    grid.innerHTML = "";
    items.forEach(item => {
      const div = document.createElement("div");
      div.className = "item";
      const hasImage = !!(item.image && String(item.image).trim().length > 0);
      const textScaleParam = Number.isFinite(Number(item.scale)) ? Number(item.scale) : 1;
      const textScaleFactor = Math.max(0.1, 1 - 0.1 * (textScaleParam - 1));
      console.log(`Item: ${item.name}, HasImage: ${hasImage}, Scale: ${textScaleParam}, Factor: ${textScaleFactor}`);
      div.innerHTML = `
        <div class="swipe-bg"><span class="minus">-1</span></div>
        <div class="item-content">
          ${hasImage ? `<img src="${item.image}" alt="${item.name}">` : `<div class=\"no-image\" data-scale-adjust=\"${textScaleFactor}\" data-scale-level=\"${textScaleParam}\" data-color=\"${item.color || 'black'}\"><span class=\"no-image-text\">${item.name}</span></div>`}
          ${counts[item.name] > 0 ? `<div class=\"count\">${counts[item.name]}</div>` : ""}
          <div class="label">${item.name}</div>
        </div>
      `;
      if (!hasImage) {
        div.classList.add('no-image-mode');
        // support manual line breaks ("\n") in names when no image
        const span = div.querySelector('.no-image-text');
        if (span) {
          console.log(`Raw item name: "${item.name}"`);
          console.log(`Raw item name length: ${item.name.length}`);
          console.log(`Raw item name char codes: ${Array.from(item.name).map(c => c.charCodeAt(0))}`);
          
          // Handle newlines more directly
          let processedText = item.name || "";
          if (processedText.includes('\\n')) {
            // Replace literal \n with actual newlines, then with <br> tags
            processedText = processedText.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
            console.log(`Found \\n, processed to: "${processedText}"`);
          }
          
          const safe = processedText
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          
          console.log(`Final HTML: "${safe}"`);
          span.innerHTML = safe;
          
          // Force proper line breaks for items with explicit newlines
          if (item.name && item.name.includes('\\n')) {
            console.log(`Found \\n in name, applying special styling to: "${item.name}"`);
            span.style.whiteSpace = 'pre-line';
            span.style.wordBreak = 'normal';
            span.style.overflowWrap = 'normal';
            span.style.hyphens = 'none';
            span.style.lineHeight = '0.8';  // Very tight line spacing for multi-line text
            
            // Add multi-line class to the container
            const noImageDiv = div.querySelector('.no-image');
            if (noImageDiv) {
              noImageDiv.classList.add('multi-line');
              console.log(`Added multi-line class to container for: "${item.name}"`);
            } else {
              console.log(`ERROR: Could not find .no-image div for: "${item.name}"`);
            }
          } else {
            console.log(`No \\n found in name: "${item.name}"`);
            // Check for actual newlines (not just literal \n)
            if (item.name && item.name.includes('\n')) {
              console.log('FOUND ACTUAL NEWLINES! Applying multi-line styling');
              span.style.whiteSpace = 'pre-line';
              span.style.wordBreak = 'normal';
              span.style.overflowWrap = 'normal';
              span.style.hyphens = 'none';
              span.style.lineHeight = '0.8';
              
              // Add multi-line class to the container
              const noImageDiv = div.querySelector('.no-image');
              if (noImageDiv) {
                noImageDiv.classList.add('multi-line');
                console.log(`Added multi-line class for ACTUAL newlines: "${item.name}"`);
              }
            }
          }
        }
      }
      let suppressClick = false;
      const content = div.querySelector('.item-content');
      // Image fallback: replace with large text if image fails to load
      const imgEl = div.querySelector('img');
      if (imgEl) {
        imgEl.addEventListener('error', () => {
          const text = document.createElement('div');
          text.className = 'no-image';
          text.setAttribute('data-scale-adjust', String(textScaleFactor));
          text.setAttribute('data-color', item.color || 'black');
          const span = document.createElement('span');
          span.className = 'no-image-text';
          // Handle newlines more directly
          let processedText = item.name || "";
          if (processedText.includes('\\n')) {
            // Replace literal \n with actual newlines, then with <br> tags
            processedText = processedText.replace(/\\n/g, '\n').replace(/\n/g, '<br>');
          }
          
          const safe = processedText
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
          
          span.innerHTML = safe;
          
          // Force proper line breaks for items with explicit newlines
          if (item.name && item.name.includes('\\n')) {
            span.style.whiteSpace = 'pre-line';
            span.style.wordBreak = 'normal';
            span.style.overflowWrap = 'normal';
            span.style.hyphens = 'none';
            span.style.lineHeight = '0.8';  // Very tight line spacing for multi-line text
            
            // Add multi-line class to the container
            text.classList.add('multi-line');
          }
          text.appendChild(span);
          imgEl.replaceWith(text);
          div.classList.add('no-image-mode');
          // CONTROLLED SCALING: Re-enable scaling but only for multi-line text
          if (text.classList.contains('multi-line')) {
            console.log('Applying controlled scaling to multi-line fallback text');
            requestAnimationFrame(() => fitTextToBoxControlled(text));
          }
        });
      } else {
        // If we rendered text directly, ensure it fits
        const text = div.querySelector('.no-image');
        // CONTROLLED SCALING: Re-enable scaling but only for multi-line text
        if (text && text.classList.contains('multi-line')) {
          console.log('FOUND MULTI-LINE TEXT - classes:', text.classList.toString());
          console.log('Container element:', text);
          requestAnimationFrame(() => fitTextToBoxControlled(text));
        } else if (text) {
          console.log('NOT MULTI-LINE - classes:', text.classList.toString());
        }
        
        // DEBUG: Log what's happening with this container
        if (text) {
          console.log('Text container found:', text);
          console.log('Container classes:', text.className);
          console.log('Container computed style:', window.getComputedStyle(text));
          const span = text.querySelector('.no-image-text');
          if (span) {
            console.log('Text span style:', window.getComputedStyle(span));
            console.log('Text span transform:', span.style.transform);
          }
        }
      }
      div.addEventListener("click", (event) => {
        if (suppressClick) { suppressClick = false; return; }
        counts[item.name]++;
        updateTotal();
        renderMenu();
      });

      // Swipe-to-decrement (left or down swipe)
      let startX = null, startY = null, dragging = false, currentDX = 0, currentDY = 0, dragAxis = null;
      div.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        startX = t.clientX; startY = t.clientY;
        dragging = false; currentDX = 0; currentDY = 0; dragAxis = null;
        if (content) content.style.transition = "none";
      }, { passive: true });
      div.addEventListener("touchmove", (e) => {
        if (startX === null) return;
        const t = e.touches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        if (!dragging) {
          if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
            dragging = true; dragAxis = 'x';
          } else if (Math.abs(dy) > 10 && Math.abs(dy) > Math.abs(dx)) {
            dragging = true; dragAxis = 'y';
          }
        }
        if (dragging && dragAxis) {
          e.preventDefault();
          currentDX = dx;
          currentDY = dy;
          if (dragAxis === 'x') {
            const translateX = Math.min(0, dx); // only left
            if (content) content.style.transform = `translateX(${translateX}px)`;
            div.classList.toggle('dragging', translateX < 0);
          } else if (dragAxis === 'y') {
            const translateY = Math.max(0, dy); // only down
            if (content) content.style.transform = `translateY(${translateY}px)`;
            div.classList.toggle('dragging', translateY > 0);
          }
        }
      }, { passive: false });
      const endSwipe = () => {
        if (dragging) {
          const leftSwipe = currentDX <= -50;
          const downSwipe = currentDY >= 50;
          if ((leftSwipe || downSwipe) && counts[item.name] > 0) {
            counts[item.name]--;
            updateTotal();
            suppressClick = true;
            renderMenu();
          }
          if (content) {
            content.style.transition = "transform 0.15s ease";
            content.style.transform = "translate(0, 0)";
          }
          div.classList.remove('dragging');
        }
        startX = startY = null; dragging = false; currentDX = 0; currentDY = 0; dragAxis = null;
      };
      div.addEventListener("touchend", endSwipe);
      div.addEventListener("touchcancel", endSwipe);
      grid.appendChild(div);
    });
    layoutGrid();
  }

  // Controlled scaling specifically for multi-line text
  function fitTextToBoxControlled(el) {
    if (!el) {
      console.log('fitTextToBoxControlled: No element provided');
      return;
    }
    const span = el.querySelector('.no-image-text');
    if (!span) {
      console.log('fitTextToBoxControlled: No text span found');
      return;
    }
    
    console.log('fitTextToBoxControlled: Starting controlled scaling');
    console.log('Element:', el);
    console.log('Span:', span);
    console.log('Span innerHTML:', span.innerHTML);
    
    // Force a smaller font size for multi-line text
    console.log('FORCING smaller font size for multi-line text');
    span.style.fontSize = '0.7rem';
    span.style.lineHeight = '0.9';
    
    // Also try to measure and log dimensions
    setTimeout(() => {
      const containerHeight = el.clientHeight;
      const textHeight = span.scrollHeight;
      console.log(`After font change - Container height: ${containerHeight}px, Text height: ${textHeight}px`);
    }, 100);
  }

  // Fit big bold text into a square box using transform scale only
  function fitTextToBox(el) {
    if (!el) return;
    const span = el.querySelector('.no-image-text');
    if (!span) return;
    // Reset baseline so measurement is consistent
    span.style.transform = 'scale(1)';
    span.style.fontSize = '100px';
    span.style.width = '100%';
    // Base margin (35%) and per-item scale factor (1..10 => 100%..10%)
    const userFactorRaw = parseFloat(el.getAttribute('data-scale-adjust') || '1');
    const userFactor = Number.isFinite(userFactorRaw) ? userFactorRaw : 1;
    
    // Check if this is multi-line text (has newlines)
    const isMultiLine = span.innerHTML.includes('<br>') || span.innerHTML.includes('\n');
    
    // Use different scaling approach for multi-line text
    let factor;
    if (isMultiLine) {
      // For multi-line text, use much more conservative scaling to ensure all lines fit
      factor = 0.25 * userFactor;  // Much less aggressive scaling
      console.log(`fitTextToBox: MULTI-LINE text, userFactor=${userFactor}, factor=${factor}`);
    } else {
      factor = 0.65 * userFactor;
      console.log(`fitTextToBox: single-line text, userFactor=${userFactor}, factor=${factor}`);
    }
    
    // Measure available vs content size
    const cw = el.clientWidth || 1;
    const ch = el.clientHeight || 1;
    const rect = span.getBoundingClientRect();
    const sw = rect.width || 1;
    const sh = rect.height || 1;
    
    // For multi-line text, be more conservative with height scaling
    let scale;
    if (isMultiLine) {
      // Prioritize fitting the height over width for multi-line text
      const widthScale = cw / sw;
      const heightScale = ch / sh;
      scale = Math.max(0.1, Math.min(1, factor * Math.min(widthScale, heightScale * 1.2))); // Give 20% more height allowance
    } else {
      scale = Math.max(0.1, Math.min(1, factor * Math.min(cw / sw, ch / sh)));
    }
    
    console.log(`fitTextToBox: final scale=${scale}, isMultiLine=${isMultiLine}`);
    console.log(`Container dimensions: ${cw}x${ch}, Content dimensions: ${sw}x${sh}`);
    console.log(`Text content: "${span.innerHTML}"`);
    
    // Apply scale without affecting layout by using transform-origin and ensuring no overflow
    span.style.transform = `scale(${scale})`;
    span.style.transformOrigin = 'center center';
    
    // Ensure the scaled text doesn't affect cell dimensions but allow text to be visible
    el.style.overflow = 'visible';
    
    // Log the final result for debugging
    console.log(`Text scaling complete: scale=${scale}, container overflow=${el.style.overflow}`);
  }

  function layoutGrid() {
    const grid = document.getElementById("menuGrid");
    if (!grid) return;
    const n = items.length || 0;
    const styles = getComputedStyle(grid);
    const gap = parseFloat(styles.gap) || 12;
    const paddingLeft = parseFloat(styles.paddingLeft) || 12;
    const paddingRight = parseFloat(styles.paddingRight) || 12;
    const paddingTop = parseFloat(styles.paddingTop) || 12;
    const paddingBottom = parseFloat(styles.paddingBottom) || 12;
    const footer = document.querySelector(".footer");
    const footerHeight = footer ? footer.getBoundingClientRect().height : 0;
    const availableWidth = window.innerWidth - paddingLeft - paddingRight;
    const availableHeight = window.innerHeight - footerHeight - paddingTop - paddingBottom;

    let bestCols = Math.min(3, n || 3);
    let bestTileWidth = 0;
    let bestLabelFont = 14;
    const maxCols = Math.min(Math.max(1, n), 8);
    for (let cols = 1; cols <= maxCols; cols++) {
      const rows = Math.max(1, Math.ceil(n / cols));
      const tileWidth = (availableWidth - gap * (cols - 1)) / cols;
      const labelFont = Math.max(11, Math.min(16, Math.round(tileWidth * 0.15)));
      const labelHeight = labelFont + 12; // font size + vertical padding
      const tileHeight = tileWidth + labelHeight;
      const totalHeight = rows * tileHeight + gap * (rows - 1);
      if (tileWidth > bestTileWidth && totalHeight <= availableHeight) {
        bestTileWidth = tileWidth;
        bestCols = cols;
        bestLabelFont = labelFont;
      }
    }
    // If nothing fit, pick the configuration that yields the largest tiles and then clamp height
    if (bestTileWidth === 0) {
      let bestScore = -Infinity;
      for (let cols = 1; cols <= maxCols; cols++) {
        const rows = Math.max(1, Math.ceil(n / cols));
        const tileWidth = (availableWidth - gap * (cols - 1)) / cols;
        const labelFont = Math.max(11, Math.min(16, Math.round(tileWidth * 0.15)));
        const labelHeight = labelFont + 12;
        const tileHeight = tileWidth + labelHeight;
        const totalHeight = rows * tileHeight + gap * (rows - 1);
        const score = tileWidth - Math.max(0, totalHeight - availableHeight); // prefer large tiles with less overflow
        if (score > bestScore) {
          bestScore = score;
          bestCols = cols;
          bestTileWidth = tileWidth;
          bestLabelFont = labelFont;
        }
      }
    }
    grid.style.setProperty("--cols", String(bestCols));
    document.documentElement.style.setProperty("--label-font", `${bestLabelFont}px`);
    grid.style.setProperty("--dec-top", `${Math.max(24, Math.floor(bestTileWidth * 0.35))}px`);
    // Refit any fallback text boxes after layout changes - DISABLED to prevent interference
    // grid.querySelectorAll('.no-image').forEach((el) => fitTextToBox(el));
  }

  window.addEventListener("resize", layoutGrid);

  function updateTotal() {
    const total = items.reduce((sum, item) => sum + counts[item.name] * item.price, 0);
    document.getElementById("total").textContent = total.toFixed(2);
  }

  document.getElementById("resetBtn").onclick = () => {
    for (let key in counts) counts[key] = 0;
    updateTotal();
    renderMenu();
  };

  init();
</script>
</body>
</html>
