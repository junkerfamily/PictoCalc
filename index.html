<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pictogram Order Calculator</title>
<link rel="icon" href="/favicon.ico">
<link rel="icon" type="image/png" href="images/hamburger.png">
<style>
  body {
    font-family: system-ui, sans-serif;
    margin: 0;
    display: flex;
    flex-direction: column;
    background: #fafafa;
    height: 100vh; /* fallback */
  }

  /* Use dynamic viewport height where supported to keep footer in view on mobile */
  @supports (height: 100dvh) {
    body { height: 100dvh; }
  }

  /* Grid layout */
  .grid {
    flex: 1;
    display: grid;
    grid-template-columns: repeat(var(--cols, 3), 1fr);
    gap: var(--gap, 12px);
    padding: 12px;
    box-sizing: border-box;
  }

  /* Item card */
  .item {
    position: relative;
    background: white;
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 3px 8px rgba(0,0,0,0.12);
    transition: transform 0.15s ease;
    cursor: pointer;
    touch-action: manipulation;
  }
  .item:active {
    transform: scale(0.95);
  }

  /* Swipe layers */
  .item-content {
    position: relative;
    z-index: 1;
    transition: transform 0.15s ease;
    will-change: transform;
  }
  .swipe-bg {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: flex-end;
    padding-right: 12px;
    opacity: 0;
    transition: opacity 0.15s ease;
    pointer-events: none;
    z-index: 0;
  }
  .swipe-bg .minus {
    background: #ff4444;
    color: #fff;
    padding: 6px 10px;
    border-radius: 999px;
    font-weight: bold;
    box-shadow: 0 2px 6px rgba(0,0,0,0.15);
  }
  .item.dragging .swipe-bg {
    opacity: 1;
  }

  /* Fallback when image is missing: big bold text fits square */
  .no-image {
    width: 100%;
    aspect-ratio: 1 / 1;
    display: grid;
    place-items: center;
    text-align: center;
    font-weight: 900;
    color: #222;
    background: #fff;
    padding: 2px;
    box-sizing: border-box;
    /* Prefer wrapping at word boundaries; allow breaking if needed */
    white-space: normal;
    word-break: break-word;
    overflow-wrap: anywhere;
    hyphens: auto;
    line-height: 1.0;
  }
  .no-image-text {
    display: block;
    width: 100%;
    will-change: transform;
    transform-origin: center center;
  }
  .no-image-mode .label { display: none; }

  /* Item image */
  .item img {
    width: 100%;
    display: block;
    aspect-ratio: 1 / 1;
    object-fit: contain;
    background: #fff;
  }

  /* Name label */
  .label {
    text-align: center;
    padding: 6px;
    font-size: var(--label-font, 14px);
    font-weight: 500;
    color: #333;
  }

  /* Count badge */
  .count {
    position: absolute;
    top: 6px;
    right: 6px;
    background: #ff4444;
    color: white;
    padding: 4px 8px;
    border-radius: 20px;
    font-size: 13px;
    min-width: 20px;
    text-align: center;
    font-weight: bold;
  }

  /* Swipe hint (only visible while swiping) */
  .item.swiping::after {
    content: "Swipe left to remove";
    position: absolute;
    right: 10px;
    top: 50%;
    transform: translateY(-50%);
    font-size: 12px;
    color: #888;
    background: rgba(255,255,255,0.85);
    padding: 4px 6px;
    border-radius: 6px;
    pointer-events: none;
  }

  /* Footer total bar */
  .footer {
    background: white;
    border-top: 1px solid #ddd;
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 18px;
    font-weight: bold;
    box-shadow: 0 -2px 6px rgba(0,0,0,0.06);
    position: sticky;
    bottom: 0;
  }

  /* Reset button */
  button {
    background: #ff4444;
    color: white;
    border: none;
    padding: 8px 14px;
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s ease;
  }
  button:hover {
    background: #dd2222;
  }

  /* Error banner */
  .error {
    background: #fff3cd;
    color: #664d03;
    border-bottom: 1px solid #ffe69c;
    padding: 8px 12px;
    font-size: 14px;
    display: none;
  }
</style>
</head>
<body>

<div id="error" class="error"></div>

<!-- Menu Grid -->
<div class="grid" id="menuGrid"></div>

<!-- Total Footer -->
<div class="footer">
  <button id="resetBtn">Reset</button>
  <div>Total: $<span id="total">0.00</span></div>
</div>

<script>
  let items = [];
  let counts = {};

  async function init() {
    try {
      const url = `config.json?ts=${Date.now()}`;
      const res = await fetch(url, { cache: "no-store" });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      items = await res.json();
      hideError();
    } catch (err) {
      console.error("Failed to load config.json", err);
      showError("Failed to load config.json. If running locally, start a server: python3 -m http.server");
      items = [];
    }
    counts = Object.fromEntries(items.map(i => [i.name, 0]));
    renderMenu();
  }

  function showError(message) {
    const el = document.getElementById("error");
    if (!el) return;
    el.textContent = message;
    el.style.display = "block";
  }

  function hideError() {
    const el = document.getElementById("error");
    if (!el) return;
    el.style.display = "none";
  }

  function renderMenu() {
    const grid = document.getElementById("menuGrid");
    grid.innerHTML = "";
    items.forEach(item => {
      const div = document.createElement("div");
      div.className = "item";
      const hasImage = !!(item.image && String(item.image).trim().length > 0);
      div.innerHTML = `
        <div class="swipe-bg"><span class="minus">-1</span></div>
        <div class="item-content">
          ${hasImage ? `<img src="${item.image}" alt="${item.name}">` : `<div class=\"no-image\"><span class=\"no-image-text\">${item.name}</span></div>`}
          ${counts[item.name] > 0 ? `<div class=\"count\">${counts[item.name]}</div>` : ""}
          <div class="label">${item.name}</div>
        </div>
      `;
      if (!hasImage) {
        div.classList.add('no-image-mode');
      }
      let suppressClick = false;
      const content = div.querySelector('.item-content');
      // Image fallback: replace with large text if image fails to load
      const imgEl = div.querySelector('img');
      if (imgEl) {
        imgEl.addEventListener('error', () => {
          const text = document.createElement('div');
          text.className = 'no-image';
          const span = document.createElement('span');
          span.className = 'no-image-text';
          span.textContent = item.name;
          text.appendChild(span);
          imgEl.replaceWith(text);
          div.classList.add('no-image-mode');
          requestAnimationFrame(() => fitTextToBox(text));
        });
      } else {
        // If we rendered text directly, ensure it fits
        const text = div.querySelector('.no-image');
        if (text) requestAnimationFrame(() => fitTextToBox(text));
      }
      div.addEventListener("click", (event) => {
        if (suppressClick) { suppressClick = false; return; }
        counts[item.name]++;
        updateTotal();
        renderMenu();
      });

      // Swipe-to-decrement (left or down swipe)
      let startX = null, startY = null, dragging = false, currentDX = 0, currentDY = 0, dragAxis = null;
      div.addEventListener("touchstart", (e) => {
        const t = e.touches[0];
        startX = t.clientX; startY = t.clientY;
        dragging = false; currentDX = 0; currentDY = 0; dragAxis = null;
        if (content) content.style.transition = "none";
      }, { passive: true });
      div.addEventListener("touchmove", (e) => {
        if (startX === null) return;
        const t = e.touches[0];
        const dx = t.clientX - startX;
        const dy = t.clientY - startY;
        if (!dragging) {
          if (Math.abs(dx) > 10 && Math.abs(dx) > Math.abs(dy)) {
            dragging = true; dragAxis = 'x';
          } else if (Math.abs(dy) > 10 && Math.abs(dy) > Math.abs(dx)) {
            dragging = true; dragAxis = 'y';
          }
        }
        if (dragging && dragAxis) {
          e.preventDefault();
          currentDX = dx;
          currentDY = dy;
          if (dragAxis === 'x') {
            const translateX = Math.min(0, dx); // only left
            if (content) content.style.transform = `translateX(${translateX}px)`;
            div.classList.toggle('dragging', translateX < 0);
          } else if (dragAxis === 'y') {
            const translateY = Math.max(0, dy); // only down
            if (content) content.style.transform = `translateY(${translateY}px)`;
            div.classList.toggle('dragging', translateY > 0);
          }
        }
      }, { passive: false });
      const endSwipe = () => {
        if (dragging) {
          const leftSwipe = currentDX <= -50;
          const downSwipe = currentDY >= 50;
          if ((leftSwipe || downSwipe) && counts[item.name] > 0) {
            counts[item.name]--;
            updateTotal();
            suppressClick = true;
            renderMenu();
          }
          if (content) {
            content.style.transition = "transform 0.15s ease";
            content.style.transform = "translate(0, 0)";
          }
          div.classList.remove('dragging');
        }
        startX = startY = null; dragging = false; currentDX = 0; currentDY = 0; dragAxis = null;
      };
      div.addEventListener("touchend", endSwipe);
      div.addEventListener("touchcancel", endSwipe);
      grid.appendChild(div);
    });
    layoutGrid();
  }

  // Fit big bold text into a square box (binary search font size)
  function fitTextToBox(el) {
    if (!el) return;
    // Use text length to set an initial guess to speed convergence
    const text = el.textContent || "";
    const words = text.trim().split(/\s+/).filter(Boolean);
    const longestWordLen = words.reduce((m,w) => Math.max(m, w.length), 1);
    const chars = Math.max(1, text.length);
    const container = el.getBoundingClientRect();
    const targetArea = container.width * container.height;
    // heuristic: area per char (bigger for short words)
    const areaPerChar = Math.max(600, Math.min(8000, targetArea / Math.sqrt(chars)));
    let guess = Math.sqrt(areaPerChar);
    // Ensure longest word can fit: estimate max width per character row
    // Nudge size down based on longest word to encourage wrapping when needed
    const longestWordFactor = Math.max(1, longestWordLen / 5);
    // Binary search with better initial bounds
    let low = 6, high = Math.min(480, Math.max(guess * 2 / longestWordFactor, 48));
    let best = low;
    for (let i = 0; i < 14; i++) {
      const mid = (low + high) / 2;
      el.style.fontSize = mid + 'px';
      // Use scrollHeight/Width vs client to detect overflow
      const fits = el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight;
      if (fits) { best = mid; low = mid; } else { high = mid; }
    }
    // small margin, then reduce by 35% as requested
    el.style.fontSize = Math.max(8, Math.floor((best - 2) * 0.65)) + 'px';
    // If it still doesn't fit (e.g., single long word), allow per-letter break and refit smaller
    if (el.scrollWidth > el.clientWidth || el.scrollHeight > el.clientHeight) {
      el.style.wordBreak = 'break-all';
      el.style.hyphens = 'manual';
      let low2 = 6, high2 = parseFloat(getComputedStyle(el).fontSize) || 60, best2 = low2;
      for (let i = 0; i < 10; i++) {
        const mid2 = (low2 + high2) / 2;
        el.style.fontSize = mid2 + 'px';
        const fits2 = el.scrollWidth <= el.clientWidth && el.scrollHeight <= el.clientHeight;
        if (fits2) { best2 = mid2; low2 = mid2; } else { high2 = mid2; }
      }
      el.style.fontSize = Math.max(8, Math.floor((best2 - 1) * 0.65)) + 'px';
    }
  }

  function layoutGrid() {
    const grid = document.getElementById("menuGrid");
    if (!grid) return;
    const n = items.length || 0;
    const styles = getComputedStyle(grid);
    const gap = parseFloat(styles.gap) || 12;
    const paddingLeft = parseFloat(styles.paddingLeft) || 12;
    const paddingRight = parseFloat(styles.paddingRight) || 12;
    const paddingTop = parseFloat(styles.paddingTop) || 12;
    const paddingBottom = parseFloat(styles.paddingBottom) || 12;
    const footer = document.querySelector(".footer");
    const footerHeight = footer ? footer.getBoundingClientRect().height : 0;
    const availableWidth = window.innerWidth - paddingLeft - paddingRight;
    const availableHeight = window.innerHeight - footerHeight - paddingTop - paddingBottom;

    let bestCols = Math.min(3, n || 3);
    let bestTileWidth = 0;
    let bestLabelFont = 14;
    const maxCols = Math.min(Math.max(1, n), 8);
    for (let cols = 1; cols <= maxCols; cols++) {
      const rows = Math.max(1, Math.ceil(n / cols));
      const tileWidth = (availableWidth - gap * (cols - 1)) / cols;
      const labelFont = Math.max(11, Math.min(16, Math.round(tileWidth * 0.15)));
      const labelHeight = labelFont + 12; // font size + vertical padding
      const tileHeight = tileWidth + labelHeight;
      const totalHeight = rows * tileHeight + gap * (rows - 1);
      if (tileWidth > bestTileWidth && totalHeight <= availableHeight) {
        bestTileWidth = tileWidth;
        bestCols = cols;
        bestLabelFont = labelFont;
      }
    }
    // If nothing fit, pick the configuration that yields the largest tiles and then clamp height
    if (bestTileWidth === 0) {
      let bestScore = -Infinity;
      for (let cols = 1; cols <= maxCols; cols++) {
        const rows = Math.max(1, Math.ceil(n / cols));
        const tileWidth = (availableWidth - gap * (cols - 1)) / cols;
        const labelFont = Math.max(11, Math.min(16, Math.round(tileWidth * 0.15)));
        const labelHeight = labelFont + 12;
        const tileHeight = tileWidth + labelHeight;
        const totalHeight = rows * tileHeight + gap * (rows - 1);
        const score = tileWidth - Math.max(0, totalHeight - availableHeight); // prefer large tiles with less overflow
        if (score > bestScore) {
          bestScore = score;
          bestCols = cols;
          bestTileWidth = tileWidth;
          bestLabelFont = labelFont;
        }
      }
    }
    grid.style.setProperty("--cols", String(bestCols));
    document.documentElement.style.setProperty("--label-font", `${bestLabelFont}px`);
    grid.style.setProperty("--dec-top", `${Math.max(24, Math.floor(bestTileWidth * 0.35))}px`);
    // Refit any fallback text boxes after layout changes
    grid.querySelectorAll('.no-image').forEach((el) => fitTextToBox(el));
  }

  window.addEventListener("resize", layoutGrid);

  function updateTotal() {
    const total = items.reduce((sum, item) => sum + counts[item.name] * item.price, 0);
    document.getElementById("total").textContent = total.toFixed(2);
  }

  document.getElementById("resetBtn").onclick = () => {
    for (let key in counts) counts[key] = 0;
    updateTotal();
    renderMenu();
  };

  init();
</script>
</body>
</html>
